\documentclass{article}

\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage{listings}
\usepackage[hidelinks]{hyperref}
\usepackage[margin=1in]{geometry}

% for box diagrams
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning}

\begin{document}

\title{COMP 520 - Final Report (GoLite)}
\author{
\textbf{Group 14}\\
Alexandre St-Louis Fortier (260720127)\\
Stefan Knudsen (260678259)\\
Cheuk Chuen Siow (260660584)}
\maketitle

\raggedright
\section{Introduction}
New programming languages are being conceived every other year to tackle various kinds of problems. The structure of a computer program are dependent on the syntax and semantics of a given programming language, and the correctness of the program has to be exact for a compiler to translate it to a machine language. Since the number of programming languages is on the rise, the study on compiler design is imperative to actually understand the tools and how the whole compilation process works. Our group decided to work on the GoLite project as the source-to-source compiler.

We chose OCaml [1] as our implementation language for compiler construction because the recursive nature of the language allows for easy manipulation of abstract syntax tree (AST). In addition, the pattern matching feature that OCaml provides is particularly helpful in constructing the compiler and has been applied to most parts of the compiler. The tools that we used for building the scanner and parser are \verb|ocamllex| and \verb|Menhir| [2,3,4]. The maturity of the parsing and scanning tools were another reason for the choice of OCaml. What's more, the lead TA had pointed out that OCaml is a good language for such a project.

As for the target language, we have chosen to generate WebAssembly (or \verb|wasm|) [5], a low-level programming language that attempts to be more efficient than JavaScript for the web browser. In particular, our compiler generates WebAssembly [6,7]. Since WebAssembly is currently in the experimental stage, only a handful of documentations about the language exist and even some of them are not complete. So far we have only encountered 2 compilers that translates a particular language to WebAssembly: emscripten [8] from LLVM to JavaScript (\verb|asm.js|, the predecessor of \verb|wasm|), and ilwasm [9] from C\# to \verb|wasm|. As such, our compiler that takes GoLite programs and generates WebAssembly is a timely project.

The next section is about the design of the compiler structure and all its phases, followed by some examples comparing GoLite programs and the generated WebAssembly code, and ended with a brief discussion and future work.

\section{Compiler Structure}
\begin{center}
\tikzstyle{block} = [draw, rectangle, minimum height=3em, minimum width=3em]
\tikzstyle{virtual} = [coordinate]
\begin{tikzpicture}[>=stealth,auto, node distance=2cm]
  \node [virtual] (input)     {};
  \node [block, right of=input] (scanner) {Scanner};
  \node [block, right of=scanner] (parser) {Parser};
  \node [block, right of=parser] (weeder) {Weeder};
  \node [block, below of=scanner] (tcheck) {Type Checker};
  \node [block, below of=weeder] (simp) {Type Simplifier};
  \node [block, below of=tcheck] (gen) {Code Generation};
  \node [virtual, right of=gen] (output)     {};

  %% \draw [->] (input) -- node {$x$} (scanner);
  %% \draw [->] (scanner) -- node [name=y] {$y$}(pout);
  \draw [->] (input) -- node {} (scanner);
  \draw [->] (scanner) -- node {} (parser);
  \draw [->] (parser) -- node {} (weeder);
  \draw [->] (weeder) -- node {} (tcheck);
  \draw [->] (tcheck) -- node {} (simp);
  \draw [->] (simp) -- node {} (gen);
  \draw [->] (gen) -- node {} (output);

  \end{tikzpicture}
\end{center}

\subsection{Scanner}
The lexical analysis phase of the compiler scans the source code (GoLite program) as a stream of characters and searches for valid tokens that are defined in \verb|lexer.mll|. Programs with any tokens that are not recognized by the scanner such as invalid literals or block comments will be rejected by the compiler, otherwise it will proceed to the next phase.

For inserting semicolon token according to Go semicolon insertion rule 1, we added a variable \verb|insert_semic| for each of the tokens that define the insertion condition. Upon reaching a newline or end of file tokens, our program checks whether the previous token that satisfy rule 1 has updated \verb|insert_semic|, and if it evaluates to \verb|true| it will trigger the insertion of the semicolon token.

We also made a decision to handle types as identifiers and not include the primitive types as tokens. This way our parser will be able to accept both primitive types and type aliases when specifying types. We also decided to defer the check for invalid use of primitive types in variable identifiers to the weeding phase.

\subsection{Parser}
The syntax analysis phase of the compiler parses the tokens generated by the scanner and checks whether the combination of the tokens form a syntactically valid grammar. This phase is needed due to the limitations of regular expressions---context-free grammar is able to recognize balancing tokens for example. Production rules are defined in \verb|parser.mly| which generates a parse tree for the subsequent phases.

Note that we took the token definitions from \verb|parser.mly| and placed them into a separate file \verb|tokens.mly|. Along with the flags defined in \verb|myocamlbuild.mly|, this enables the main program to display a list of tokens from the tokenizer.

\subsection{Weeder}
The weeder checks for invalid programs that is difficult to implement in the parser. In particular, we check for
\begin{itemize}
  \item Invalid use of basic types (\verb|int|, \verb|float64|, \verb|bool|, \verb|rune|, \verb|string|) as an identifier, since we didn't specify those basic types as keywords.
  \item Invalid use of underscore.
  \item Negative index for arrays.
  \item Invalid use of expression as expression statement or left value.
  \item Multiple \verb|default| in a switch statement.
  \item Invalid use of \verb|break| and \verb|continue| outside of loops.
\end{itemize}

\subsection{Symbol Table}
Initially, the symbol table consisted of a list of maps (as in dictionaries). We briefly considered the alpha-renaming approach, but since hash tables are typically used for symbol table because of its performance, we ended up changing the symbol table to utilize hash tables instead.

The way we design the symbol table is to implement a cactus stack of hash tables, as had been presented in class. The root represents the global scope with a hash table which stores the information for top-level declarations. Whenever a block is entered, a new frame is generated. This frame (\verb|F|) has a new hash table associated with the new scope, and also has a pointer to the parent frame. This allows for the lookup of a declaration starting from the innermost scope that \verb|F| resides, and recursively traverse towards the root node through the parent frame, but not the neighboring nodes as the scopes of these nodes and \verb|F| are disjoint.

We went a little off of what was suggested to handle some of the primitives. This can be seen with our extended type system which includes \verb|TKind| types. We use \verb|TKind| as the type of variables. So all base types have type \verb|TKind(TSimp("#"))| where \verb|"#"| is the type at the top of the type hierarchy. The use of \verb|TKind| allowed us to handle type checking as the function call of a \verb|TKind| identifier. Accordingly, \verb|type| statements add a symbol of type \verb|TKind| to the symbol table.

Since our AST doesn't encode the last position of a node, it was difficult to print the last line of a scope. Instead we provide an alternative view of the symbol table with the \verb|-smartsymtab| flag which gives a better view of how some symbols shadow others.

\subsection{Type Checker}
Type checking closely followed the \verb|typechecker.pdf|. New scopes are added at the beginning of every block, and at the end of every block, the top hash table is popped. At variable, type, and function declarations, a check is made to see if the \verb|id| has been declared in the current scope. A type error is raised if it's already been declared.

Because of the initial idea of using an immutable map rather than a mutable hash table, type checking consisted of ``threading'' the context through lists, that is, mapping while passing each context onto the next element of the list. Since we decided not to use the map, this is no longer needed, (simply mapping suffices).

Because type declaration is allowed in GoLite, the approach of matching the types and operators that we had seen for the \verb|minilang| compiler wouldn't work. We took the approach of pattern matching on the operator and check if two types were unifiable. If their upper bound were belonged to the class of types allowable for the operator, then the upper bound was the type returned.

\subsection{Type Simplifier}
Before passing the annotated AST to code generator, we convert type aliases to their base types. This is to simplify the code generation phase as WebAssembly has only numbers as primitive types and does not support type declarations.

\subsection{Code Generation}
There are two kinds of formats that represent WebAssembly code: WebAssembly TextFormat (\verb|.wast|) code which uses an AST representation in S-expression syntax, and WebAssembly binary-encoding (\verb|.wasm|). Current tools that deal with these files include \verb|sexpr-wasm-prototype| [10] which translates WebAssembly TextFormat to binary-encoding, and \verb|binaryen| [11] which is a compiler that parses and emits WebAssembly files. Our compiler generates the WebAssembly TextFormat code.

Below are some of the constructs that are uncommon and worth mentioning here. We follow the specification as defined in [6,7].

\subsubsection{Local variables}
WebAssembly requires that variable declarations in a function to be defined at the top of the function body (\verb|local|) before they are used. As such, all variables local to a function has only a single scope. To overcome this limitation, we append the GoLite type and scope level to the variable names. We use \verb|set_local| and \verb|get_local| instructions for any operations that deal with global variables.

\subsubsection{Global variables}
WebAssembly does not support global variables. The way we implement global variables is to make use of linear memory. For each top-level declarations, we enclosed them in functions which will be called at the beginning of the start program, and assign a location to the memory address to store the declaration. This information is stored in a hash table for later usage. We use \verb|store| and \verb|load| instructions for any operations that deal with global variables.

\subsubsection{Types}
WebAssembly supports 32-/64-bit integer and 32-/64-bit floating point as the base types, but not the others. We take the 32-bit integer to represent the integer in GoLite, whereas rune, bool, and string are represented as 32-bit integer in WebAssembly. Strings are stored in memory, so integer type for strings represents the memory location. The value for 32-bit integer takes 4 bytes of the memory, whereas 64-bit float takes 8 bytes.

\subsubsection{Control flow structures}
WebAssembly has basic control flow structures including \verb|block|, \verb|loop|, and \verb|if| statements. We make use of \verb|block| and \verb|label| to implement \verb|for| loops and \verb|switch| statements. For nested statements with multiple scoping, we can make a reference to a named label that is defined by the closest outer enclosing construct, so labels in different scopes but have the same name do not have conflicting results.

\subsubsection{Print statements}
WebAssembly does not have native support for printing to console. A way to include printing is to import a module from \verb|spectest|, but that also has its limitations in that it can only print WebAssembly integers and floats verbatim. Alexandre implemented proper printing mechanism in \verb|binaryen| in his forked copy of the repository [12], and we use that program to parse the generated S-expression code.

\section{Examples}
\subsubsection*{GoLite}
The following is a simple GoLite program.

\begin{lstlisting}
package main

func main() {
  var x, y int = 2, 3
  if z := 1; z == 0 {
    x = y * (z - 4)
  } else {
    y++
  }
}	
\end{lstlisting}

\subsubsection*{WebAssembly}
We can see from the generated code that we rely a lot on self-defined functions to support print and string:

\begin{lstlisting}
(module
  (memory 128 128 )
  (import $#write_i32 "spectest" "write" (param i32))
  (import $#writeln_i32 "spectest" "writeln" (param i32))
  (import $#print_i32 "spectest" "print" (param i32))
  (import $#print_f64 "spectest" "print" (param f64))
  (import $#println_i32 "spectest" "println" (param i32))
  (import $#println_f64 "spectest" "println" (param f64))
  (func $#writelni32 (param $i i32)
    (call_import $#writeln_i32 (get_local $i)))
  (func $#writei32 (param $i i32)
    (call_import $#write_i32 (get_local $i)))
  (func $#prinlntbool (param $i i32)
    (call $#printbool (get_local $i))
    (call $#writei32 (i32.const 10)))
  (func $#printbool (param $i i32)
    (if (i32.eq (get_local $i) (i32.const 0))
      (then (call $#writei32 (i32.const 116))
        (call $#writei32 (i32.const 114))
        (call $#writei32 (i32.const 117))
        (call $#writei32 (i32.const 101)))
    (else (call $#writei32 (i32.const 102))
      (call $#writei32 (i32.const 97))
      (call $#writei32 (i32.const 108))
      (call $#writei32 (i32.const 115))
      (call $#writei32 (i32.const 101)) )))
  (func $#printi32 (param $i i32)
    (call_import $#print_i32 (get_local $i)))
  (func $#printf64 (param $i f64)
    (call_import $#print_f64 (get_local $i)))
  (func $#printlni32 (param $i i32)
    (call_import $#println_i32 (get_local $i)))
  (func $#printlnf64 (param $i f64)
    (call_import $#println_f64 (get_local $i)))
  (func $#printlnstring (param $s i32) (local $n i32) (local $i i32)
    (set_local $i (i32.const 0))
    (set_local $n (i32.load (get_local $s)))
    (loop $#break $#continue
      (br_if $#break (i32.ge_u (get_local $i) (get_local $n)))
      (call $#writei32 (i32.load (i32.add (get_local $s)
        (i32.mul (i32.const 4) (i32.add (i32.const 1) (get_local $i))))))
      (set_local $i (i32.add (get_local $i) (i32.const 1)))
      (br $#continue))
    (call $#writei32 (i32.const 10)))
  (func $#printstring (param $s i32) (local $n i32) (local $i i32)
    (set_local $i (i32.const 0))
    (set_local $n (i32.load (get_local $s)))
    (loop $#break $#continue
      (br_if $#break (i32.ge_u (get_local $i) (get_local $n)))
      (call $#writei32 (i32.load (i32.add (get_local $s)
        (i32.mul (i32.const 4) (i32.add (i32.const 1) (get_local $i))))))
      (set_local $i (i32.add (get_local $i) (i32.const 1)))
      (br $#continue)))
  (func $main
    (local $x_int_1 i32)
    (local $y_int_1 i32)
    (local $z_int_2 i32)
    (set_local $x_int_1 (i32.const 2))
    (set_local $y_int_1 (i32.const 3))
    (block
      (set_local $z_int_2 (i32.const 1))
      (if (i32.eq (get_local $z_int_2) (i32.const 0))
        (then
          (set_local $x_int_1 (i32.mul (get_local $y_int_1) (i32.sub (get_local $z_int_2) (i32.const 4)))))
        (else
          (set_local $y_int_1 (i32.add (get_local $y_int_1) (i32.const 1)))))))
  (start $#init)
  (func $#init
    (i32.store (i32.const 0) (i32.const 4))
    (call $main)))
\end{lstlisting}

\section{Conclusions}
This project is challenging not only because WebAssembly is a low-level programming language, but also the scarcity of information and documentation about WebAssembly that makes it much more difficult for us to implement the code generator, especially for certain constructs such as GoLite types and string operations. Even \verb|ilwasm| [9] has not implemented proper generation of arrays and prints. Time is needed for the development of WebAssembly to mature. Even then, the speed of the development will only result in changes to the formal specification.

At the end of the project, we have come to know that building a compiler from scratch is no small feat. We have to devote our time in designing the architecture of the compiler from parsing to code generation, while maintaining the correctness of the syntax and semantics of the generated code. Even though it is a difficult process especially when dealing with a low-level programming language that has certain limitations over a high-level programming language, we have learned much from this project on what defines a computer program. We assert that the study of compiler design is crucial for programmers to understand the tools that they are using to build a computer program.

This project serves as an excellent example for the community at large to refer to a compiler that generates WebAssembly. There is still much work to be done if we were to extend GoLite to Go instead, but we hope to see that more such compilers exist so as to allow support for more programming languages to be compiled to WebAssembly code. This in turn will move the development of WebAssembly forward.

\section{Contributions}
\begin{description}
  \item [Scanner] Alexandre laid the ground work for defining the tokens. Cheuk Chuen and Alexandre defined the regular expressions for the literals.
  \item [Parser] Cheuk Chuen laid the ground work for defining the grammar and AST. Alexandre made important changes and thorough bug checks.
  \item [Pretty printer] Stefan worked extensively on the pretty printer.
  \item [Weeder] Alexandre wrote the weeder.
  \item [AST] Alexandre modified the AST so as to add annotations.
  \item [Symbol table] Cheuk Chuen wrote the symbol table. Alexandre made changes according to the modified type checker.
  \item [Type checker] Stefan laid the ground work for the type checker. Alexandre made changes according to the modified AST.
  \item [Pretty printer for types] Stefan modified the pretty printer to work for the new AST and to print the types of typed expressions.
  \item [Testing] Alexandre wrote shell scripts to automate testing of the existing valid and invalid programs. Cheuk Chuen wrote the majority of the tests for type checking.
  \item [Code generation] All three of us contribute to various parts of the code generation.
\end{description}

\section{References}
\begin{enumerate}
  \item \url{https://ocaml.org/}
  \item \url{http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual026.html}
  \item \url{https://realworldocaml.org/v1/en/html/parsing-with-ocamllex-and-menhir.html}
  \item \url{http://pauillac.inria.fr/~fpottier/menhir/manual.pdf}
  \item \url{https://webassembly.github.io/}
  \item \url{https://github.com/WebAssembly/spec/blob/master/ml-proto/README.md}
  \item \url{https://github.com/WebAssembly/design/blob/master/AstSemantics.md}
  \item \url{https://github.com/kripken/emscripten}
  \item \url{https://github.com/WebAssembly/ilwasm}
  \item \url{https://github.com/WebAssembly/sexpr-wasm-prototype}
  \item \url{https://github.com/WebAssembly/binaryen}
  \item \url{https://github.com/astlouisf/binaryen}
\end{enumerate}

\end{document}
